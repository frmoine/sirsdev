/**
 * This file is part of SIRS-Digues 2.
 *
 * Copyright (C) 2016, FRANCE-DIGUES,
 * 
 * SIRS-Digues 2 is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * SIRS-Digues 2 is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * SIRS-Digues 2. If not, see <http://www.gnu.org/licenses/>
 */
package fr.sirs.plugin.vegetation;

import fr.sirs.Injector;
import fr.sirs.SIRS;
import fr.sirs.Session;
import fr.sirs.core.model.PlanVegetation;
import fr.sirs.core.model.Preview;
import fr.sirs.core.model.TronconDigue;
import static fr.sirs.plugin.vegetation.FXPlanTable.CHECKBOX_NO_LABEL_PADDING;
import static fr.sirs.plugin.vegetation.FXPlanTable.Mode.EXPLOITATION;
import static fr.sirs.plugin.vegetation.VegetationSession.NON_PLANIFIE_NON_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.NON_PLANIFIE_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.PLANIFIE_NON_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.PLANIFIE_TRAITE;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.FXCollections;
import javafx.embed.swing.SwingFXUtils;
import javafx.fxml.FXML;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.Tab;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Background;
import javafx.scene.layout.Border;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.util.StringConverter;
import org.geotoolkit.font.FontAwesomeIcons;
import org.geotoolkit.font.IconBuilder;

/**
 * Panneau de représentation des parcelles pour l'exploitation.
 * 
 * "Exploitation" > "Exploitation"
 *
 * @author Johann Sorel (Geomatys)
 * 
 * @see FXPlanTable
 */
public class FXExploitationPane extends BorderPane {

    @FXML private Tab tabTraitements;
    @FXML private Tab tabImpression;
    @FXML private BorderPane uiPlanTable;
    @FXML private GridPane uiHeader;

    final ComboBox<Integer> uiAnneeChoice = new ComboBox<>();
    final CheckBox filterPlanifieNonTraite = new CheckBox(PLANIFIE_NON_TRAITE);
    final CheckBox filterNonPlanifieTraite = new CheckBox(NON_PLANIFIE_TRAITE);
    final CheckBox filterPlanifieTraite = new CheckBox(PLANIFIE_TRAITE);
    final CheckBox filterNonPlanifieNonTraite = new CheckBox(NON_PLANIFIE_NON_TRAITE);

    public static final String PLANIFIE_FUTUR = "Planifié (futur)";
    public static final String NON_PLANIFIE_FUTUR = "Non planifié (futur)";

    public FXExploitationPane() {
        super();
        SIRS.loadFXML(this);

        final Session session = Injector.getSession();

        // Choix du tronçon.
        final ComboBox<Preview> uiTroncons = new ComboBox<>();
        SIRS.initCombo(uiTroncons, SIRS.observableList(session.getPreviews().getByClass(TronconDigue.class)).sorted(), null);
        final Label lblTroncon = new Label("Tronçon : ");
        lblTroncon.getStyleClass().add("label-header");
        lblTroncon.setMinWidth(30);

        uiHeader.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        uiHeader.getStyleClass().add("blue-light");
        uiHeader.setHgap(10);
        uiHeader.setVgap(10);
        uiHeader.setPadding(new Insets(10, 10, 10, 10));
        uiHeader.add(lblTroncon, 1, 0);
        uiHeader.add(uiTroncons, 2, 0);
        final Label lblTitle = new Label("Exploitation des parcelles");
        lblTitle.setPadding(new Insets(0, 40, 0, 40));
        lblTitle.getStyleClass().add("label-header");
        lblTitle.setStyle("-fx-font-size: 1.5em;");
        uiHeader.add(lblTitle, 0, 0);

        filterPlanifieNonTraite.setSelected(true);
        filterNonPlanifieTraite.setSelected(true);
        filterPlanifieTraite.setSelected(true);
        filterNonPlanifieNonTraite.setSelected(true);

        filterPlanifieNonTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());
        filterNonPlanifieTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());
        filterPlanifieTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());
        filterNonPlanifieNonTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());

        final Button filterAction = new Button("Filter sur l'année");
        filterAction.setOnAction(e -> uiPlanTable.setCenter(new FXPlanTable(VegetationSession.INSTANCE.planProperty().getValue(), uiTroncons.getValue() == null? null : uiTroncons.getValue().getElementId(), EXPLOITATION, buildsFilter(), uiAnneeChoice.getValue()==null?0:uiAnneeChoice.getValue())));
        filterAction.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());

        final Button resetFilterAction = new Button("Réinitialiser");
        resetFilterAction.setOnAction(e -> {
            filterPlanifieNonTraite.setSelected(true);
            filterNonPlanifieTraite.setSelected(true);
            filterPlanifieTraite.setSelected(true);
            filterNonPlanifieNonTraite.setSelected(true);
            uiAnneeChoice.getSelectionModel().select(null);
            uiPlanTable.setCenter(new FXPlanTable(VegetationSession.INSTANCE.planProperty().getValue(), uiTroncons.getValue() == null? null : uiTroncons.getValue().getElementId(), EXPLOITATION, buildsFilter(), uiAnneeChoice.getValue()==null?0:uiAnneeChoice.getValue()));
                });
        resetFilterAction.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());

        final HBox filter = new HBox(uiAnneeChoice, filterNonPlanifieNonTraite, filterPlanifieNonTraite, filterNonPlanifieTraite, filterPlanifieTraite, filterAction, resetFilterAction);
        filter.setSpacing(30);
        uiHeader.add(filter, 0, 1, 3, 1);

        final Button lblInfo = new Button(null, new ImageView(SwingFXUtils.toFXImage(IconBuilder.createImage(FontAwesomeIcons.ICON_INFO_CIRCLE, 32, Color.WHITE),null)));
        lblInfo.setBackground(Background.EMPTY);
        lblInfo.setBorder(Border.EMPTY);
        lblInfo.setPadding(Insets.EMPTY);
        lblInfo.setOnMouseClicked(e -> new InfoStage().showAndWait());

        lblTitle.setPadding(new Insets(0, 10, 0, 40));
        uiHeader.add(lblInfo, 5, 0);

        tabTraitements.setContent(new FXTraitementsPane());

        if(VegetationSession.INSTANCE.planProperty().getValue()!=null){
            loadTable(uiTroncons.getValue() == null? null : uiTroncons.getValue().getElementId());
        }

        //on ecoute les changements de troncon et de plan
        final ChangeListener chgListener = new ChangeListener() {
            @Override
            public void changed(ObservableValue observable, Object oldValue, Object newValue) {
                if(VegetationSession.INSTANCE.planProperty().getValue()!=null){
                    loadTable(uiTroncons.getValue() == null? null : uiTroncons.getValue().getElementId());
                }
            }
        };

        VegetationSession.INSTANCE.planProperty().addListener(new WeakChangeListener(chgListener));
        uiTroncons.valueProperty().addListener(chgListener);

        tabImpression.setContent(new BorderPane(new FXImpression()));
    }

    private void loadTable(final String tronconId){
        uiPlanTable.setCenter(new FXPlanTable(VegetationSession.INSTANCE.planProperty().getValue(), tronconId, EXPLOITATION, buildsFilter(), uiAnneeChoice.getValue()==null?0:uiAnneeChoice.getValue()));

        final List<Integer> annees = new ArrayList<>();
        final PlanVegetation plan = VegetationSession.INSTANCE.planProperty().getValue();
        final int nbAnnees = plan.getAnneeFin() - plan.getAnneeDebut();
        for(int i=0; i<nbAnnees; i++){
            annees.add(i);
        }
        annees.add(null);

        uiAnneeChoice.setItems(FXCollections.observableList(annees));
        uiAnneeChoice.setConverter(new StringConverter<Integer>() {

            private final String defaultString = "";
            @Override
            public String toString(Integer object) {
                if(object==null) return defaultString;
                else return String.valueOf(object + plan.getAnneeDebut());
            }

            @Override
            public Integer fromString(String string) {
                if(defaultString.equals(string)) return null;
                else return Integer.getInteger(string)-plan.getAnneeDebut();
            }
        });
    }


    private List<String> buildsFilter(){
        if(uiAnneeChoice.getValue()==null) return null;
        else{
            final List<String> result = new ArrayList<>();
            if(!filterPlanifieNonTraite.isSelected()) result.add(PLANIFIE_NON_TRAITE);
            if(!filterNonPlanifieTraite.isSelected()) result.add(NON_PLANIFIE_TRAITE);
            if(!filterPlanifieTraite.isSelected()) result.add(PLANIFIE_TRAITE);
            if(!filterNonPlanifieNonTraite.isSelected()) result.add(NON_PLANIFIE_NON_TRAITE);
            return result;
        }
    }

    /**
     * Legend display.
     */
    private static class InfoStage extends Stage {

        private InfoStage(){
            super(StageStyle.UNDECORATED);
            final GridPane grid = new GridPane();
            grid.setPadding(new Insets(10, 10, 10, 10));
            grid.setHgap(10);
            grid.setVgap(10);

            final Label lgdTitle = new Label("Légende :");
            lgdTitle.setStyle("-fx-font-weight: bold; -fx-underline: true;");
            grid.add(lgdTitle, 0, 0, 2, 1);

            final CheckBox npf = new CheckBox();
            npf.setDisable(true);
            npf.setSelected(true);
            npf.setPadding(new Insets(10));
            npf.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npf, null);
            grid.add(npf, 0, 1);
            grid.add(new Label("Parcelle planifiée (l'année courante ou dans l'avenir) et non traitée."), 1, 1);

            final CheckBox pt = new CheckBox();
            pt.setDisable(true);
            pt.setSelected(true);
            pt.setPadding(new Insets(10));
            pt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(pt, PLANIFIE_TRAITE);
            grid.add(pt, 0, 2);
            grid.add(new Label("Parcelle planifiée et traitée."), 1, 2);

            final CheckBox pnt = new CheckBox();
            pnt.setDisable(true);
            pnt.setSelected(true);
            pnt.setPadding(new Insets(10));
            pnt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(pnt, PLANIFIE_NON_TRAITE);
            grid.add(pnt, 0, 3);
            grid.add(new Label("Parcelle planifiée (dans le passé) et non traitée."), 1, 3);

            final CheckBox npt = new CheckBox();
            npt.setDisable(true);
            npt.setSelected(false);
            npt.setPadding(new Insets(10));
            npt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npt, NON_PLANIFIE_TRAITE);
            grid.add(npt, 0, 4);
            grid.add(new Label("Parcelle non planifiée mais traitée."), 1, 4);

            final CheckBox npnt = new CheckBox();
            npnt.setDisable(true);
            npnt.setSelected(false);
            npnt.setPadding(new Insets(10));
            npnt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npnt, NON_PLANIFIE_NON_TRAITE);
            grid.add(npnt, 0, 5);
            grid.add(new Label("Parcelle ni planifiée ni traitée."), 1, 5);

            final Button ok = new Button("Fermer");
            ok.setOnAction(ev -> hide());
            grid.add(ok, 0, 6, 2, 1);
            GridPane.setHalignment(ok, HPos.CENTER);

            setScene(new Scene(grid));
            initModality(Modality.APPLICATION_MODAL);
        }

    }
}
